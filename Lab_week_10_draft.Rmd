---
title: "Biology 351: Lab Week 10"
output: html_notebook
---

*Introdution*

We are back to R to analyze and plot our allele frequency data for the last several weeks of class. Last week you generated a filtered vcf file using just your two samples; you'll use this next week to do a SNP-by-SNP FST analysis. I created the same filtered vcf file that included all of the samples. This week we are going to do more filtering of SNPs in R and ultimately run and plot a principal component analysis with our data.

To start, I have already turned the data encoded in the AD and RD columns spaces of the vcf into an R data table. It was downloaded as part of the bundle from github.

**Question:** What do AD and RD stand for? What information do they hold?

**Answer here:**

**Question** How did I convert RD and AD into an allele frequency? Note that we will calculate frequencies of the reference allele. 

**Answer here**

*Part 1: Principal Components Analysis (PCA)*

When we do our analysis we want to remove SNPs for two reason. First, SNPs that are closely linked will tend to have correlated allele frequencies and may bias our analysis. Second

Actually calculating linkage in the pooled data is more complicated than we have time for, so we are going to use a shortcut to downsample our data without actually measuring linkage between SNPs.

 
```{r}
library(data.table)
library(foreach)
#library(doMC)
#registerDoMC(4)

#read in vcf allelle frequency data. Will load in as a data.table called freqs.wide
load("/scratch/perickso/private/bio351/ZP_processed_freqs_wide.Rdata")


```
**Question** How many SNPs are in our dataset?
**Answer here:**

**Question:** The genome of Z. indianus is approximately 140 Mb. How often is there a SNP in our data?
**Answer here:** 

**Question:** If we want to have approximately 1 SNP every 1000 bases, what fraction of the SNPs will we retain?
**Answer here**

The code below is going to divide our data up into windows that are 1000 bp long, and then sample one SNP every 1000 bp.  It will take way too long. But take a look at it and try to understand what some of the steps are doing.

```{r}
# Print every unique contig, and for every contig, randomly subsample 1 SNP per 5000 bp window


window<-1000 #complete this 

#make sure "pos" column is a numeric column not character
freqs.wide[,pos:=as.numeric(pos)]
setkey(freqs.wide, chr, pos, marker)

#start by looping through each of 5 chromosomes
y<-foreach(i=c(1:5))%do%{
  #print which chromosome we are working on
  print(paste0("chrom= ", i))
  #pull out just the snps on chromosome i
  snp.subset<-freqs.wide[chr==i]
  #determine maximum position in the contig, which will help us figure out how many windows we need
  max<-max(snp.subset$pos)
  #determine number of windows
  number.windows<-round(max/window)
  #loop through each window and identify one random SNP
  z<-foreach(j=c(0:number.windows), .errorhandling="remove") %dopar% {
    #print the start position of the window if we are on a multiple of one million
    if(((window*j)%%1000000)==0){
     print(window*j)
    }
    #determine the beginning and end of the sliding window
    window.start=window*j
    window.end=window*(j+1)
     #pull out only snps in the window (pos>window start and pos < window end )
    subset_window<-snp.subset[pos>=window.start & pos<window.end]
    #if subset_window has 0 rows, return nothing
    if(nrow(subset_window)==0){
      return()}
    #pick one random snp ID from the subset
    chosen_snp=sample(subset_window$marker, 1)
    #return the row of the data table that 
    return(subset_window[marker==chosen_snp])
  }
  #combine all the chosen rows into a data table
  return(rbindlist(z))
}
#combine each chromosome into a final data table
y<-rbindlist(y)
```
**Question** Why is the first step a for loop over integers 1 to 5?
**Answer here**


**Question:** How did the code calculate the number of windows to make?
**Answer here**

**Question** what does "j" refer to in the code? (this is a tricky question-ask me if you aren't sure)
**Answer here**

**Question** What is the name of the function that picks a random element from a set  of values?
**Answer here**

**Question** What is going to be the name of the final data table object?
**Answer here**

**Question** When the code is done running, take a look at your final data table with the downsampled SNPs. Does the number of SNPs match what you would expect? Why or why not?
**Answer here**

Great! Now we have a set of what should be mostly unlinked SNPs to do our PCA. 

First let's do a principal components analysis using our downsampled data for the entire genome. Note that while most of the PCA we have looked at in class has used genotypes of individuals at many SNPs to calculate PCA, we can also use allele frequencies at many SNPs for a similar calculation

```{r}
#first determine which columns of y have the allele frequency data
first_column=4
last_column=13
#now run this code
  #this line isolates only the allele frequency data columns
  pca.matrix<-as.matrix(y[,first_column:last_column])
#this assigns marker names to each row of the matrix
  rownames(pca.matrix)=y$marker
#only want SNPs with calls in all pops
  pca.matrix.complete<-na.omit(pca.matrix)
  #calculate PCA
  pca.results<-prcomp(pca.matrix.complete, scale=T)
  pca.data<-as.data.table(pca.results$rotation)
  pca.data[,Pool:=rownames(pca.results$rotation)]

```
**Question** Compare your `pca.dat` object iwth your partner's. Are the values identical? Why or why not? (hint think about the steps that we did to prepare the data for this)

**Answer here**

To make an informative plot, we need to bring in some information about each sample so we know what we are looking at and can color-code our points appropriately

```{r}
info<-fread("~/shared/samples.csv")
#look at the columns in info. What is the name of the column that is shared in comon with pca.data?
#set up the command below to merge the sample and pca data

pca.data<-merge(pca.data, info, by="name.of.shared.column")
pca.data<-merge(pca.data, info, by="Pool")##Delete for students

```


Now let's make some plots of our whole-genome PCA data. First make a plot comparing the samples by collection location 
```{r}
ggplot(pca.data)+geom_point(x=PC1, 
                            y=PC2,
                            color=Location)
```

Next, copy the code above and modify to plot by year instead
```{r}

```

Lastly, let's make a plot that highlights the two samples you'll be comparing for your analysis

```{r}

```

**Question** What trends do you observe in your plots? Can you make any comment about genetic similarity of the samples overall?

**Answer here**

**Question** Compared to the overall variation in the samples, how similar are your two samples that you'll be comparing?
**Answer here**

We were focusing on the whole genome, but previous research on Zaprionus has suggested that there are some interesting trends of population differentiation going on with individual chromosomes. Let's repeat our PCA but now we will calculate the PCA for each chromosome separately and compare. 

```{r}
pca.chrom<-foreach(chrom=c(1:5))%do%{
  print(chrom)
  first_column=4
  last_column=13
  #echromosdit this line of code to pull out only one 
  y.chrom<-y[chr==chrom,first_column:last_column]
  pca.matrix.chrom<-as.matrix(y.chrom)
#this assigns marker names to each row of the matrix
  rownames(pca.matrix.chrom)=y.chrom$marker
#only want SNPs with calls in all pops
  pca.matrix.chrom.complete<-na.omit(pca.matrix.chrom)
  #calculate PCA for the chromosome
  pca.results.chrom<-prcomp(pca.matrix.chrom.complete, scale=T)
  #turn it into a data table
  pca.data.chrom<-as.data.table(pca.results.chrom$rotation)
  #add names of pools
  pca.data.chrom[,Pool:=rownames(pca.results.chrom$rotation)]
  return(pca.data.chrom)
}
pca.chrom<-rbindlist(pca.chrom)

```

Now we'll make the same plots we made above, but plot each chromosome separately with the `facet_wrap` command in `ggplot`
```{r}

```


*Part 2: Genome-wide FST between all pairs of samples*

For this part we are going to use a package called poolfstat. This package is specifically designed to do FST and other population genetic tests on pooled sequencing data. In a funny coincidence, the person who wrote this package is Matthieu Gautier, the first author of the ladybug paper we read this week (I did not plan this at all!)

**Question:** What do you think "pairwise' FST means? 
**Answer here**

Now run the code below to read our full vcf file into the poolfstat. It needs to know the names and number of individuals in each pool, which is found in our previously-loaded "info" file. Because the order of the samples is different between teh two files, we have to tell it to read the poolnames and poolsizes out of order. 

```{r}
info[,month:=c("Aug", "June", "Aug", "Sept", "Oct", "Aug", "Aug", "Oct", "Aug", "Oct")]
info[,sample_name:=paste(Location, month, Year, sep="_")]
write.csv(info, "/scratch/perickso/private/bio351/sample_info.csv")
vcf.dat<-vcf2pooldata(vcf.file="/scratch/perickso/private/bio351/ZP_all_noindel_no_repeats_filtered.recode.vcf.gz",
                  poolnames=info$sample_name[c(10,1:9)],
                  poolsizes=info$total[c(10,1:9)],
                  min.cov.per.pool=15)

pfst<-compute.pairwiseFST(vcf.dat,verbose=TRUE)

```
Let's look at the pfst object created in our last command
```{r}
pfst@PairwiseFSTmatrix
```

**Question** What is shown in these data?
**Answer here**

**Question** Why are there "NA"s along a diagonal line?
**Answer here**

The poolfstat package includes a function to create a heatmap of the FST values
```{r}
heatmap(pfst)
```
